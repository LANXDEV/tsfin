# Copyright (C) 2016-2018 Lanx Capital Investimentos LTDA.
#
# This file is part of Time Series Finance (tsfin).
#
# Time Series Finance (tsfin) is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# Time Series Finance (tsfin) is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Time Series Finance (tsfin). If not, see <https://www.gnu.org/licenses/>.
"""
FxYieldCurveTimeSeries, a class to handle a time series of Fx Swap Yield Curves

"""

import QuantLib as ql
import numpy as np
from tsio import TimeSeriesCollection
from operator import attrgetter
from tsfin.base import to_ql_date, conditional_vectorize
from tsfin.curves.yieldcurve import YieldCurveTimeSeries, ExtRateHelper


class FxYieldCurveTimeSeries(YieldCurveTimeSeries):

    def __init__(self, base_yield_curve, ts_collection=None, calendar=None, day_counter=None,
                 keep_only_on_the_run_month=False, ignore_errors=False, curve_type='linear_zero', freeze_curves=True,
                 enable_extrapolation=True, frozen_curve_interpolation_type='monotonic_cubic_zero',
                 constraint_at_zero=True, **other_rate_helper_args):
        super().__init__(ts_collection=ts_collection, calendar=calendar, day_counter=day_counter,
                         keep_only_on_the_run_month=keep_only_on_the_run_month, ignore_errors=ignore_errors,
                         curve_type=curve_type, freeze_curves=freeze_curves, enable_extrapolation=enable_extrapolation,
                         frozen_curve_interpolation_type=frozen_curve_interpolation_type,
                         constraint_at_zero=constraint_at_zero, **other_rate_helper_args)
        self.base_yield_curve = base_yield_curve
        self.currencies = TimeSeriesCollection()
        self.fx_spot_price = dict()

    def _get_helpers(self, date):

        helpers = dict()
        self.fx_spot_price[date] = None
        base_yield_curve = self.base_yield_curve.yield_curve(date=date)
        for ts in self.ts_collection:
            ts_name = ts.ts_name
            issue_date = ts.issue_date
            helper = ts.rate_helper(date=date, **self.other_rate_helper_args)
            self.currencies.add(ts.currency_ts)
            if self.fx_spot_price[date] is None:
                fx_rate = ts.currency_spot_rate.value()
                self.fx_spot_price[date] = ql.SimpleQuote(fx_rate)

            ts.currency_spot_handle.linkTo(self.fx_spot_price[date])
            ts.term_structure.linkTo(base_yield_curve)

            if helper is not None:
                maturity_date = helper.maturityDate()
                helper = ExtRateHelper(ts_name=ts_name, issue_date=issue_date, maturity_date=maturity_date,
                                       helper=helper)
                # Remove Helpers with the same maturity date (or tenor), keeping the last issued one - This is to avoid
                # error in QuantLib when trying to instantiate a yield curve with two helpers with same maturity
                # date or tenor.
                existing_helper = helpers.get(maturity_date, None)
                if existing_helper is None:
                    helpers[maturity_date] = helper
                else:
                    helpers[maturity_date] = max((helper, existing_helper), key=attrgetter('issue_date'))

        if self.keep_only_on_the_run_month:
            # If self.keep_only_on_the_run_month is True, then filter the returned helpers so that for each month there
            # is not more than one helper. This may be used to avoid distortions in curves being generated by a large
            # amount of TimeSeries.
            month_end_helpers = dict()
            for maturity_date, helper in helpers.items():
                month_year = self._date_to_month_year(maturity_date)
                existing_helper = month_end_helpers.get(month_year, None)
                if existing_helper is None:
                    month_end_helpers[month_year] = helper
                else:
                    month_end_helpers[month_year] = max((helper, existing_helper), key=attrgetter('issue_date'))
            helpers = {ndhelper.maturity_date: ndhelper for ndhelper in month_end_helpers.values()}

        return helpers

    @conditional_vectorize('date', 'to_date')
    def implied_fx_rate_to_date(self, date, to_date):

        date = to_ql_date(date)
        to_date = to_ql_date(to_date)
        to_time = self.day_counter.yearFraction(date, to_date)
        continuous_rate = self.zero_rate_to_time(date, to_time, ql.Continuous, ql.NoFrequency)
        fx_spot = self.fx_spot_price[date].value()
        return fx_spot*np.exp(continuous_rate*to_time)
